<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="x-ua-compatible" content="IE=Edge"/>
    
    <title>NVIDIA VXGI Programming Guide &mdash; NVIDIA VXGI 2.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/breathe.css" type="text/css" />
    <link rel="stylesheet" href="_static/application.css" type="text/css" />
    <link rel="stylesheet" href="_static/styleguide.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/bootstrap.js"></script>
    <script type="text/javascript" src="_static/jquery.cookie.js"></script>
    <script type="text/javascript" src="_static/jquery.storageapi.js"></script>
    <link rel="top" title="NVIDIA VXGI 2.0 documentation" href="index.html" />
    <link rel="next" title="Release Notes" href="releasenotes.html" />
    <link rel="prev" title="NVIDIA VXGI" href="index.html" /> 
  </head>
  <body>
<nav class="navbar navbar-inverse navbar-default">
  <div class="row">
      <div class="navbar-brand">
             <img class="logo" src="_static/developerzone_gameworks_logo.png" alt="Logo"/>
      </div>
<div id="searchbox" style="display: none; float:right; padding-top:4px; padding-right:4px">
    <form class="search form-inline" action="search.html" method="get">
      <div class="form-group">
      <input type="text" name="q" class="form-control" />
      <input type="submit" value="Search" class="btn btn-primary" />
      </div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  </div>
</nav>
<div class="masthead">
    <div class="row">
      <ul class="breadcrumb">
        <li><a href="index.html">NVIDIA VXGI 2.0 documentation</a></li> 
      </ul>
    </div>
</div>
<div class="row">
  <div class="col-md-3 bs-sidenav" style="white-space: nowrap; overflow: auto;">
<div class="bs-sidebar">
  <div id="sidebar_toc">
  <h4>Table Of Contents</h4>
  <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="">NVIDIA VXGI Programming Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#what-s-in-the-package">What&#8217;s in the Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="#getting-started">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="#voxelizing-scene-geometry">Voxelizing scene geometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="#voxelizing-light">Voxelizing light</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ambient-occlusion-vxao-mode">Ambient occlusion (VXAO) mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="#area-lighting">Area Lighting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#debugging-voxelization">Debugging voxelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#custom-g-buffer-support">Custom G-buffer Support</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="releasenotes.html">Release Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="releasenotes.html#vxgi-2-0-1">VXGI 2.0.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="releasenotes.html#vxgi-2-0-0">VXGI 2.0.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="releasenotes.html#new-features">New Features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#vxal-or-voxel-area-lighting">VXAL, or Voxel Area Lighting</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#combined-voxelization">Combined voxelization</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#support-for-custom-g-buffer-layouts">Support for custom G-buffer layouts</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#view-reprojection">View reprojection</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#simultaneous-vxgi-and-vxao">Simultaneous VXGI and VXAO</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#separate-ssao-pass">Separate SSAO pass</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#non-cubic-voxel-volumes">Non-cubic voxel volumes</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#support-for-pre-view-translation">Support for pre-view translation</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#stateless-voxelization-view-set-up">Stateless voxelization view set-up</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="releasenotes.html#other-changes">Other Changes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#improved-performance">Improved performance</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#simpler-and-more-intuitive-tracing-controls">Simpler and more intuitive tracing controls</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#reduced-light-leaking">Reduced light leaking</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#finer-control-over-rendering-api-extensions-being-used">Finer control over rendering API extensions being used</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#opacity-dimensionality-control-removed">Opacity dimensionality control removed</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#emittance-format-control-removed">Emittance format control removed</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#simpler-materialinfo-structure-and-more-flexible-voxelization-shaders">Simpler MaterialInfo structure and more flexible voxelization shaders</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#tracer-vision-debug-mode-removed">Tracer Vision debug mode removed</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#emittance-coverage-supersampling-mode-removed">Emittance coverage supersampling mode removed</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#improved-nvrhi">Improved NVRHI</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#opengl-support-removed">OpenGL support removed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="releasenotes.html#known-issues">Known Issues</a><ul>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#indirect-lighting-quality-is-still-not-perfect">Indirect lighting quality is still not perfect</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#specular-reflections-are-blurry-floating-and-misshapen">Specular reflections are blurry, floating, and misshapen</a></li>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html#area-light-shadows-have-poor-contact-hardening">Area light shadows have poor contact hardening</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">NVIDIA VXGI</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="releasenotes.html"
                        title="next chapter">Release Notes</a></p>
<div id="searchbox" style="display: none">
  <h4>Quick search</h4>
    <form class="search form-inline" action="search.html" method="get">
      <div class="form-group">
      <input type="text" name="q" class="form-control" />
      <input type="submit" value="Search" class="btn btn-primary" />
      </div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
</div>
  </div>
    <div class="document col-md-8">
          <div class="body">
            
  <div class="section" id="productname-programming-guide">
<h1>NVIDIA VXGI Programming Guide<a class="headerlink" href="#productname-programming-guide" title="Permalink to this headline">¶</a></h1>
<div class="section" id="what-s-in-the-package">
<h2>What&#8217;s in the Package<a class="headerlink" href="#what-s-in-the-package" title="Permalink to this headline">¶</a></h2>
<p><strong>VXGI headers, libraries and DLLs</strong></p>
<table class="table">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>/VXGI/include/*.h</td>
<td>VXGI header files</td>
</tr>
<tr class="row-even"><td>/VXGI/lib/*.lib</td>
<td>VXGI library files (compiled with VS 2015)</td>
</tr>
<tr class="row-odd"><td>/VXGI/examplecode/...</td>
<td>Exemplar implementation of the rendering backend
(a layer between VXGI and D3D11/12)</td>
</tr>
<tr class="row-even"><td>/VXGI/bin/GFSDK_VXGI*.dll</td>
<td>VXGI DLLs (one per platform)</td>
</tr>
</tbody>
</table>
<p><strong>Docs</strong></p>
<table class="table">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>/doc/...</td>
<td>Documentation files</td>
</tr>
</tbody>
</table>
<p><strong>Sample files</strong></p>
<table class="table">
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>/samples/GFSDK_VXGI_Samples_2015.sln</td>
<td>The solution file that contains the sample projects</td>
</tr>
<tr class="row-even"><td>/samples/AmbientOcclusion/...</td>
<td>The Ambient Occlusion sample source code</td>
</tr>
<tr class="row-odd"><td>/samples/GlobalIllumination/...</td>
<td>The Global Illumination sample source code</td>
</tr>
<tr class="row-even"><td>/samples/AreaLighting/...</td>
<td>The Area Lighting sample source code</td>
</tr>
<tr class="row-odd"><td>/samples/media/...</td>
<td>Scene files used in the samples</td>
</tr>
<tr class="row-even"><td>/samples/nvidia/utils/...</td>
<td>Helper code for window, 3D device and camera manipulation</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="getting-started">
<h2>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h2>
<p>To start using VXGI with your rendering engine, you should:</p>
<ol class="arabic simple">
<li>Add a reference to <tt class="docutils literal"><span class="pre">GFSDK_VXGI_platform.lib</span></tt> where <tt class="docutils literal"><span class="pre">platform</span></tt> is either <tt class="docutils literal"><span class="pre">x86</span></tt> or <tt class="docutils literal"><span class="pre">x64</span></tt>.</li>
<li>Put <tt class="docutils literal"><span class="pre">GFSDK_VXGI_platform.dll</span></tt> into the output directory of the project. Alternatively, load them explicitly using <tt class="docutils literal"><span class="pre">LoadLibrary</span></tt> WinAPI function.</li>
<li>Copy or include the files <tt class="docutils literal"><span class="pre">GFSDK_NVRHI_(D3D11/D3D12).cpp,</span> <span class="pre">.h</span></tt> into the project to get a reference implementation of the NVRHI backend (rendering hardware interface, a D3D proxy). If this reference implementation doesn’t fit your engine, feel free to modify it.</li>
<li>Use the latest available version of NVAPI library – it’s required for certain features in the backend implementation, specifically SLI support and extended rasterizer state.</li>
<li>Include <tt class="docutils literal"><span class="pre">GFSDK_VXGI.h</span></tt> to get all VXGI interface declarations.</li>
<li>Implement <tt class="docutils literal"><span class="pre">VXGI::IErrorCallback</span></tt> to receive error messages from VXGI.</li>
</ol>
<p>To get an indirect illumination channel from the VXGI library, the following actions have to be taken by the application:</p>
<ol class="arabic">
<li><p class="first">Create a GI object (instance of <tt class="docutils literal"><span class="pre">VXGI::IGlobalIllumination</span></tt>) by calling <tt class="docutils literal"><span class="pre">VFX_VXGI_CreateGIObject(…)</span></tt>, providing it with the NVRHI backend, error callback, and maybe a custom memory allocator.</p>
</li>
<li><p class="first">Create a shader compiler object (instance of <tt class="docutils literal"><span class="pre">VXGI::IShaderCompiler</span></tt>) by calling <tt class="docutils literal"><span class="pre">VFX_VXGI_CreateShaderCompiler(…)</span></tt>, providing it with the path to <tt class="docutils literal"><span class="pre">D3DCompiler_NN.dll</span></tt> where NN is usually 47, error callback, custom memory allocator. The compiler is required to create voxelization shaders from source code. If the shaders were compiled earlier and stored somewhere, the compiler is unnecessary and the next step can be skipped.</p>
</li>
<li><p class="first">Compile voxelization geometry and pixel shaders, at least one of each. The compiler outputs a binary blob, represented by a VXGI::IBlob object.</p>
<ol class="loweralpha simple">
<li>The voxelization geometry shader can be easily compiled from the shader in the previous stage (that is, vertex shader or domain shader) by calling <tt class="docutils literal"><span class="pre">VXGI::IShaderCompiler::compileVoxelizationGeometryShaderFromVS(…)</span></tt> or <tt class="docutils literal"><span class="pre">VXGI::</span> <span class="pre">IShaderCompiler::compileVoxelizationGeometryShaderFromDS(…)</span></tt>.</li>
<li>A simple voxelization pixel shader can be created by calling <tt class="docutils literal"><span class="pre">VXGI::IShaderCompiler::compileVoxelizationDefaultPixelShader(…)</span></tt>. This pixel shader is only good for voxelizing solid geometry for opacity, i.e. it doesn’t support alpha testing or emissive materials. Note that this shader also doesn’t expect any custom attributes to be passed through the geometry shader, so if there are some, there will be D3D runtime warnings.</li>
<li>A more advanced voxelization pixel shader can be created by calling <tt class="docutils literal"><span class="pre">VXGI::IShaderCompiler::compileVoxelizationPixelShader(…)</span></tt>, which compiles custom HLSL source code written by the application developer. The rules that have to be followed by this code are covered in the comments to the declaration of that function.</li>
</ol>
</li>
<li><p class="first">Create voxelization shader objects from compiler outputs by calling <tt class="docutils literal"><span class="pre">VXGI::IGlobalIlluminaion::loadUserDefinedShaderSet(…)</span></tt>.</p>
</li>
<li><p class="first">Set voxelization parameters, such as voxel clipmap resolution and scale, and number of LODs using the <tt class="docutils literal"><span class="pre">VXGI::IGlobalIllumination::setVoxelizationParameters(…)</span></tt> function. These parameters can be modified later, at run time, but doing so means that all VXGI resources will be released and created again, so it shouldn’t be done frequently.</p>
</li>
<li><p class="first">Create a GI tracer (instance of <tt class="docutils literal"><span class="pre">VXGI::IBasicViewTracer</span></tt>) by calling <tt class="docutils literal"><span class="pre">VXGI::IGlobalIllumination::createBasicTracer(…)</span></tt>.</p>
</li>
<li><p class="first">Voxelize the scene using this sequence of calls:</p>
<ol class="loweralpha simple">
<li><tt class="docutils literal"><span class="pre">VXGI::IGlobalIllumination::prepareForVoxelization(…)</span></tt>. This method collects information about which regions of the scene need to be updated on the current frame, and returns performOpacityVoxelization and performEmittanceVoxelization predicates that tell the application whether it should do opacity and emittance voxelization, respectively, on this frame.</li>
<li>If <tt class="docutils literal"><span class="pre">performOpacityVoxelization</span></tt> is true, voxelize scene geometry as described in the corresponding section of this document.</li>
</ol>
<ol class="loweralpha simple" start="4">
<li>If <tt class="docutils literal"><span class="pre">performEmittanceVoxelization</span></tt> is true, voxelize emissive or directly lit objects in the same way that is used for opacity voxelization, possibly using different voxelization shaders. This step can be combined with opacity voxelization by making the same draw calls add both opacity and emittance.</li>
<li>After voxelization, call <tt class="docutils literal"><span class="pre">VXGI::IGlobalIllumination::finalizeVoxelization()</span></tt> to prepare for cone tracing.</li>
</ol>
</li>
<li><p class="first">Call <tt class="docutils literal"><span class="pre">VXGI::IViewTracer::computeDiffuseChannelBasic(…)</span></tt> and/or <tt class="docutils literal"><span class="pre">computeSpecularChannelBasic(…)</span></tt>, passing the G-buffer surfaces and camera information in the <tt class="docutils literal"><span class="pre">inputBuffers</span></tt> structure. For area lighting, call <tt class="docutils literal"><span class="pre">VXGI::IBasicViewTracer::computeAreaLightChannelsBasic(...)</span></tt>.</p>
</li>
<li><p class="first">Combine the diffuse and specular, and area light diffuse and specular channels with direct lighting.</p>
</li>
</ol>
</div>
<div class="section" id="voxelizing-scene-geometry">
<h2>Voxelizing scene geometry<a class="headerlink" href="#voxelizing-scene-geometry" title="Permalink to this headline">¶</a></h2>
<p><strong>Note:</strong> to test the NVRHI backend and the basic use of VXGI library without actually voxelizing your geometry by combining pipelines and writing voxelization shaders, which is error-prone, you can call <tt class="docutils literal"><span class="pre">VXGI::IGlobalIllumination::voxelizeTestScene(…)</span></tt> after <tt class="docutils literal"><span class="pre">prepareForVoxelization(…)</span></tt>. This call produces a voxel representation of an opaque cube that emits white light. You should be able to observe this cube in the debug visualizations rendered by <tt class="docutils literal"><span class="pre">VXGI::IGlobalIllumination::renderDebug(…)</span></tt>, and the cube should illuminate other scene geometry in the results of cone tracing.</p>
<p>Voxelization is performed by the application using a graphics pipeline state that is combined from state required by VXGI (which includes geometry and pixel shaders and some resources) and state required by the application (vertex shader, possibly tessellation shaders, and resources needed for them and for the user part of the voxelization pixel shader).</p>
<p>To set the voxel space parameters and regions to update on the current frame, and to begin voxelization, call <tt class="docutils literal"><span class="pre">VXGI::IGlobalIllumination::prepareForVoxelization(…)</span></tt>.</p>
<p>After that and before voxelization, you need to get the view matrix that should be applied to your objects to transform them from world space to voxelization coordinate space. Call <tt class="docutils literal"><span class="pre">VXGI::IGlobalIllumination::getVoxelizationViewParameters(…)</span></tt> for that. Alternatively, you can use another function: <tt class="docutils literal"><span class="pre">VXGI::VFX_VXGI_ComputeVoxelizationViewParameters(...)</span></tt> which computes the same data but is stateless, so it can be called from a different thread.</p>
<p>Also, you can get the list of regions that are used by VXGI to clip voxelized geometry – use these regions to cull the meshes in order to improve performance. The regions are returned by function <tt class="docutils literal"><span class="pre">VXGI::IGlobalIllumination::getInvalidatedRegions(…)</span></tt>.</p>
<p>If either of the <tt class="docutils literal"><span class="pre">performOpacity/EmittanceVoxelization</span></tt> predicates is true, iterate over scene meshes doing the following for every mesh eligible for voxelization:</p>
<ol class="arabic simple">
<li>Fill a <tt class="docutils literal"><span class="pre">VXGI::MaterialInfo</span></tt> structure and call <tt class="docutils literal"><span class="pre">VXGI::IGlobalIllumination::getVoxelizationState(materialInfo,</span> <span class="pre">writesEmittance,</span> <span class="pre">out</span> <span class="pre">drawCallState)</span></tt> when <tt class="docutils literal"><span class="pre">materialInfo</span></tt> changes. You can call this method for every mesh, but that is inefficient.</li>
<li>Draw your geometry using one of the following methods:<ol class="loweralpha">
<li>Apply the state returned by getVoxelizationState – for example, by calling <tt class="docutils literal"><span class="pre">NVRHI::RendererInterfaceD3D11::applyState(…)</span></tt>; add the state that your parts of the pipeline need and draw the geometry using low-level rendering API calls.</li>
<li>Modify the state object returned by VXGI and add your parts of the pipeline to it; draw the geometry using <tt class="docutils literal"><span class="pre">NVRHI::IRendererInterface::draw/drawIndexed(…)</span></tt>.</li>
</ol>
</li>
</ol>
<p>When using method (2.1), don’t forget to call <tt class="docutils literal"><span class="pre">NVRHI::RendererInterfaceD3D11::clearState()</span></tt> or any other method that resets the pipeline state in order to remove the state bits used for voxelization and avoid various issues.</p>
</div>
<div class="section" id="voxelizing-light">
<h2>Voxelizing light<a class="headerlink" href="#voxelizing-light" title="Permalink to this headline">¶</a></h2>
<p>Computing a voxel representation of surfaces that reflect light is done using direct light voxelization. It means that every mesh in the scene is treated as emissive, and its emissive color is computed as reflected diffuse radiance. This method is very similar to additive forward shading, except that the results are written to a 3D texture by VXGI parts of the pixel shader code instead of a regular 2D render target.</p>
<p>The simplest way to voxelize direct light is to iterate over lights, drawing all potentially lit meshes for each light. In the voxelization pixel shader, calculate the reflected radiance using any material shaders, light parameters and shadowing techniques – just like you would for forward shading. Then pass the computed color to <tt class="docutils literal"><span class="pre">VxgiStoreVoxelizationData</span></tt> function inside the shader and that’s it. Be careful though to only set non-zero opacity once per mesh, as opacity accumulates just like emittance.</p>
<p>The shader function to call is defined as follows:</p>
<div class="highlight-python"><pre>void VxgiStoreVoxelizationData(
    VxgiVoxelizationPSInputData IN,
    float3 worldNormal,
    float opacity,
    float3 emissiveColorFront,
    float3 emissiveColorBack)
{ ... }</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">VxgiVoxelizationPSInputData</span></tt> structure is passed from the geometry shader to the pixel shader. worldNormal is the surface normal in world space, which is used to compute emittance projections. opacity is scalar opacity value, which is added to whatever is currently stored in a particular voxel, after being clamped to [0, 1] range. emissiveColorFront and emissiveColorBack are the reflected plus emitted colors of the front and back faces of the surface, respectively.</p>
<p>In order to improve performance, you can render geometry once and iterate over the lights inside the shader, or group lights in some other way based on locality.</p>
<p>Multi-bounce lighting with VXGI is performed by adding indirect irradiance in the voxelization pixel shader. Indirect irradiance is fetched by <tt class="docutils literal"><span class="pre">VxgiGetIndirectIrradiance(position,</span> <span class="pre">normal)</span></tt> shader function, which performs a lookup into the indirect irradiance map. This map is computed on the previous frame for regions which contained some geometry – but only when <tt class="docutils literal"><span class="pre">VXGI::VoxelizationParameters::enableMultiBounce</span></tt> is set to true. So, the indirect irradiance data is lagging one frame behind the direct lighting.</p>
</div>
<div class="section" id="ambient-occlusion-vxao-mode">
<h2>Ambient occlusion (VXAO) mode<a class="headerlink" href="#ambient-occlusion-vxao-mode" title="Permalink to this headline">¶</a></h2>
<p>As stated above, VXGI supports a simplified mode of operation whereby only ambient occlusion information is computed, not indirect illumination. This mode is enabled when <tt class="docutils literal"><span class="pre">VXGI::VoxelizationParameters::ambientOcclusionMode</span></tt> is set to <tt class="docutils literal"><span class="pre">true</span></tt>.</p>
<p>The general workflow in VXAO mode is not too different from regular VXGI mode, but it requires fewer steps. Specifically, emittance voxelization is not performed, which means no processing of lights or materials. If voxelized materials are all opaque, not alpha tested, the default voxelization pixel shader can be used, and only one voxelization geometry shader is necessary. The vertex shader should not produce any attributes but position in this case.</p>
<p>The <tt class="docutils literal"><span class="pre">IBasicViewTracer::computeDiffuseChannelBasic(…)</span></tt> method will produce the ambient channel in this mode, based on depth and normal G-buffer channels. The ambient channel values will be within range (0..1]. In VXGI mode, i.e. when <tt class="docutils literal"><span class="pre">VXGI::VoxelizationParameters::ambientOcclusionMode</span></tt> is false, the ambient occlusion output is still available in the alpha component of the diffuse channel.</p>
</div>
<div class="section" id="area-lighting">
<h2>Area Lighting<a class="headerlink" href="#area-lighting" title="Permalink to this headline">¶</a></h2>
<p>VXGI 2.0 adds support for high-quality area lighting. In general, any object can be made emissive in VXGI just by adding a constant to the reflected color in the voxelization pixel shader. But this approach produces highly approximate results and does not work so well for moving lights. To improve the situation, a separate pass is used to compute illumination from simple planar area lights. Currently, only rectangular lights are supported, but they can have textures, which makes it possible to draw other shapes using these textures (with some quality issues though).</p>
<p>The high-quality area lighting pass is available through the <tt class="docutils literal"><span class="pre">IBasicViewTracer::computeAreaLightChannels(...)</span></tt> method. This method accepts the G-buffer channels, like the other VXGI tracing methods; it also accepts the list of area lights with their parameters, such as position, size, orientation, color, and texture. It will produce two channels: diffuse and specular illumination from area lights. These channels should be composited into the final image like the diffuse and specular indirect lighting channels.</p>
<p>In order for this method to work, an opacity voxel representation of the scene should be built. It’s currently required even for the case when no lights have shadows enabled – but the voxels can just be empty in this case. Emittance voxels are not required, which means VXGI can be operating in VXAO mode while computing area light illumination with shadows.</p>
</div>
<div class="section" id="debugging-voxelization">
<h2>Debugging voxelization<a class="headerlink" href="#debugging-voxelization" title="Permalink to this headline">¶</a></h2>
<p>Getting voxelization code right can be quite challenging, depending on the engine. For example, when you render objects, the material system may change things like pixel shaders, resources or viewports, which breaks voxelization completely or corrupts the results beyond recognition.</p>
<p>When that happens, just use your favorite graphics debugger that can capture frames and display graphics state for draw calls. Make sure that all VXGI parts of the state are set correctly. For example, when you voxelize using a default voxelization pixel shader, and all voxelization settings are at their default values (<tt class="docutils literal"><span class="pre">mapSize</span> <span class="pre">=</span> <span class="pre">64,</span> <span class="pre">stackLevels</span> <span class="pre">=</span> <span class="pre">5</span></tt>), the state should contain the following:</p>
<ul class="simple">
<li>Geometry shader: the voxelization GS</li>
<li>Geometry shader constant buffer (<tt class="docutils literal"><span class="pre">g_VxgiVoxelizationCB</span></tt>) set and filled with reasonable data</li>
<li>Pixel shader: the voxelization PS</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>Relatively easy to recognize by presence of <tt class="docutils literal"><span class="pre">atomic_add</span></tt> instructions</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>Pixel shader constant buffer (<tt class="docutils literal"><span class="pre">g_VxgiVoxelizationCB</span></tt>) set and filled</li>
<li>Pixel shader UAVs:</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>64 x 64 x 64 3D texture (uint) for <cite>u_AllocationMap</cite></li>
<li>64 x 64 x 403 3D texture (uint) for <cite>u_Opacity</cite></li>
<li>398 x 64 x 223 3D texture (RGBA16_FLOAT) for <cite>u_EmittanceEven</cite></li>
<li>398 x 64 x 223 3D texture (RGBA16_FLOAT) for <cite>u_EmittanceOdd</cite></li>
</ul>
</div></blockquote>
<ul class="simple">
<li>Pixel shader SRVs:</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>1 x 1 x 1 3D texture (dummy, RGBA16_FLOAT) for <cite>t_IrradianceMap</cite></li>
</ul>
</div></blockquote>
<ul class="simple">
<li>Render targets:</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>No color targets</li>
<li>Square depth target (1024x1024 8xAA, not bound on DX12)</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>Rasterizer state:</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>No culling</li>
<li>Scissor enabled</li>
<li>Multisampling enabled</li>
<li>Depth clipping disabled</li>
<li>On DX12, <tt class="docutils literal"><span class="pre">forcedSampleCount</span> <span class="pre">=</span> <span class="pre">8</span></tt></li>
</ul>
</div></blockquote>
<ul class="simple">
<li>Depth-stencil state:</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>Depth disabled (yes, the depth target is not used – it’s bound only to set the multisampling mode)</li>
<li>Stencil disabled</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>Blend state:</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>Blending disabled (no render targets)</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>Viewports:</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>15 square viewports in 5 groups by 3</li>
<li>0-2: (-480…+544, -480…+544, 0…1)</li>
<li>3-5: (-224…+288, -224…+288, 0…1)</li>
<li>6-8: (-96…+160, -96…+160, 0…1)</li>
<li>9-11: (-32…+96, -32…+96, 0…1)</li>
<li>12-14: (0…+64, 0…+64, 0…1)</li>
<li>If the material has <tt class="docutils literal"><span class="pre">adaptiveMaterialSamplingRate</span> <span class="pre">=</span> <span class="pre">true</span></tt>, all viewports except the first three will be much larger.</li>
</ul>
</div></blockquote>
<ul class="simple">
<li>Scissor rectangles:</li>
</ul>
<blockquote>
<div><ul class="simple">
<li>Depends on the invalidated regions</li>
<li>When <tt class="docutils literal"><span class="pre">persistentVoxelData</span> <span class="pre">=</span> <span class="pre">false</span></tt>, all 15 scissor rects are (0…64, 0…64).</li>
</ul>
</div></blockquote>
<p>If the custom part of the voxelization pixel shader uses any other resources, like material textures or global engine constant buffers, they should also be properly bound.</p>
</div>
<div class="section" id="custom-g-buffer-support">
<h2>Custom G-buffer Support<a class="headerlink" href="#custom-g-buffer-support" title="Permalink to this headline">¶</a></h2>
<p>The other sections of this guide describe how to use the “basic” view tracer interface to compute irradiance for simple, planar projection G-buffers. But VXGI 2 comes with a feature that allows applications to supply a more complicated G-buffer setup to VXGI directly, without conversions. Such complicated setups include unusual projections like NVIDIA Multi-Res Shading and Lens Matched Shading. It also removes the requirement that normals and roughness have to be stored in a particular format. That is achieved by linking application HLSL code that reads the G-buffer with VXGI code that uses the data.</p>
<p>Custom G-buffer support is implemented using the same User-Defined Shader mechanism that’s used for voxelization shaders. First, the application HLSL code must meet certain interface requirements:</p>
<ol class="arabic">
<li><p class="first">Define struct <tt class="docutils literal"><span class="pre">VxgiGBufferSample</span></tt> and function <tt class="docutils literal"><span class="pre">VxgiGetDefaultGBufferSample()</span></tt> that returns a default value for that struct. The contents of the struct are arbitrary.</p>
</li>
<li><p class="first">Define the load function:</p>
<div class="highlight-python"><pre>bool VxgiLoadGBufferSample(float2 windowPos, uint viewIndex, bool previous, bool onlyPosition, out VxgiGBufferSample result)
{ ... }</pre>
</div>
</li>
</ol>
<p>This function returns true if there is a valid surface at windowPos pixel coordinates in view number viewIndex and fills the result structure with corresponding values. If onlyPosition is true, the implementation can only fetch and use information necessary to reconstruct the surface position at the given point.</p>
<ol class="arabic" start="3">
<li><p class="first">Define the accessor functions:</p>
<div class="highlight-python"><pre>// Returns the distance from camera to surface along the forward axis, in world units.
float VxgiGetGBufferViewDepth(VxgiGBufferSample gbufferSample);
// Returns the world position of the surface
float3 VxgiGetGBufferWorldPos(VxgiGBufferSample gbufferSample);
// Returns the world normal of the sample
float3 VxgiGetGBufferNormal(VxgiGBufferSample gbufferSample);
// Returns a tangent for the sample. Can be an arbitrary vector orthogonal to the normal.
float3 VxgiGetGBufferTangent(VxgiGBufferSample gbufferSample);
// Returns the incident vector for the surface
float3 VxgiGetGBufferViewVector(VxgiGBufferSample gbufferSample);
// Returns the clip-space position for the surface. The W component has to be 1.0 if normalized is true.
float4 VxgiGetGBufferClipPos(VxgiGBufferSample gbufferSample, bool normalized);
// Returns the right and up vectors of the camera. For most proejctions, this function would not depend on a specific sample.
void VxgiGetGBufferRightAndUp(VxgiGBufferSample gbufferSample, out float3 right, out float3 up);</pre>
</div>
</li>
<li><p class="first">Define some mapping and reprojection functions:</p>
<div class="highlight-python"><pre>// Reprojects the given sample into view # viewIndex, maybe on the previous frame. Returns true if there may be a matching surface in that view – whether it’s actually matching is determined by VXGI.
bool VxgiGetGBufferPositionInOtherView(VxgiGBufferSample gbufferSample, uint viewIndex, bool previous, out float2 prevWindowPos);
// Viewport and inverse viewport transforms
float2 VxgiGBufferMapClipToWindow(uint viewIndex, float2 clipPos);
float2 VxgiGBufferMapWindowToClip(uint viewIndex, float2 windowPos);</pre>
</div>
</li>
<li><p class="first">Define the environment mapping function that’s used for specular reflections that don’t hit any voxels:</p>
<div class="highlight-python"><pre>float3 VxgiGetEnvironmentIrradiance(float3 surfacePos, float3 coneDirection, float coneFactor, bool isSpecular);</pre>
</div>
</li>
</ol>
<p>With these functions defined, compile the tracing shaders:</p>
<div class="highlight-python"><pre>Status::Enum IShaderCompiler::compileViewTracingShaders(IBlob** ppBlob, const char* source, size_t sourceSize, const ShaderResources&amp; userShaderCodeResources);</pre>
</div>
<p>Using the returned blob (which can be stored in a file, for example), construct the tracer object:</p>
<div class="highlight-python"><pre>Status::Enum IGlobalIllumination::createCustomTracer(IViewTracer** ppTracer, IUserDefinedShaderSet* pShaderSet);</pre>
</div>
<p>Then use the custom tracer similar to the Basic tracer, but binding the G-buffer textures and constant buffers necessary for your functions through the PipelineStageBindings structure passed to the tracing functions.</p>
</div>
</div>


          </div>
      <div class="clearer"></div>
    </div>
    <div class="col-md-1"></div>
</div>
<div class="masthead">
    <div class="row">
      <ul class="breadcrumb">
        <li><a href="index.html">NVIDIA VXGI 2.0 documentation</a></li> 
      </ul>
    </div>
</div>

<footer>
    <div class="footer-boilerplate">
        <div class="row">
            <div class="boilerplate">
                Copyright &copy; 2014, NVIDIA Corporation &nbsp; | &nbsp; <a href="http://www.nvidia.com/object/about-nvidia.html" onclick="s_objectID=&quot;http://www.nvidia.com/object/about-nvidia.html_1&quot;;return this.s_oc?this.s_oc(e):true">About NVIDIA </a>&nbsp; | &nbsp; <a href="http://www.nvidia.com/object/legal_info.html" onclick="s_objectID=&quot;http://www.nvidia.com/object/legal_info.html_1&quot;;return this.s_oc?this.s_oc(e):true">Legal Information </a>&nbsp; | &nbsp; <a href="http://www.nvidia.com/object/privacy_policy.html" onclick="s_objectID=&quot;http://www.nvidia.com/object/privacy_policy.html_1&quot;;return this.s_oc?this.s_oc(e):true">Privacy Policy </a>
            </div>
        </div>
    </div>
</div>
</footer>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      processEscapes: true,
      skipTags: ["script","noscript","style","textarea"]
    },
    "HTML-CSS": { availableFonts: ["TeX"] },
    TeX: {
        Macros: {
          Lrg: ['\\displaystyle{#1}', 1, ""]
        }
      }
  });
</script>


<script type="text/javascript" async
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script>
var treestatename = 'GWDocsTreeState';
var protocol = location.href.split('/')[0].toLowerCase();
var storage;
if (protocol.substring(0,4) == 'http') {
  storage = $.cookieStorage;
  storage.setPath('/');
} else {
  storage = $.localStorage;
}

if (storage.isEmpty(treestatename)) {
  storage.set(treestatename, {});
}

var treestate = storage.get(treestatename);

$.each($("#sidebar_toc ul li"), toc_walker);

function toc_walker(key, value) {
    var handleSpan = $("<span></span>")
        .addClass("toc_handle").prependTo(value);
    handleSpan.attr("id", $(value).closest("div").attr("id") + "." + key);

    if($(value).has("ul li").size() > 0) {
        var id = handleSpan.attr("id");
        if (!(id in treestate)) {
          treestate[id] = false;
        }
        handleSpan.addClass("toc_expanded").click(function() {
            $(this).toggleClass("toc_expanded toc_collapsed").siblings("ul").toggle();
            treestate[$(this).attr('id')] = $(this).hasClass('toc_expanded');
            storage.set(treestatename, treestate);
        });
        if(!($(this).hasClass('current') || treestate[id])) {
            handleSpan.click();
        }
        if($(this).hasClass('current')) {
            treestate[handleSpan.attr('id')] = handleSpan.hasClass('toc_expanded');
            storage.set(treestatename, treestate);
        }
    }
}
</script>
  </body>
</html>